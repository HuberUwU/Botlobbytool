<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel de sincronizacion</title>
  <style>
    :root {
      --primary: #000000;
      --primary-dark: #414141;
      --secondary: #00eeff;
      --dark: #0f0f0f;
      --light: #f8fafc;
      --host-color: #f97316;
      --player-color: #3b82f6;
      --selected-color: #22c55e;
      --controlbar-gradient-start: #5c5c5c;
      --controlbar-gradient-end: #000000;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--dark);
      color: var(--light);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      box-sizing: border-box;
    }
    
    h1 {
      text-align: center;
      font-size: 20px;
      margin: 0;
      color: var(--light);
      padding: 10px 0;
      background: linear-gradient(to right, var(--controlbar-gradient-start), var(--controlbar-gradient-end));
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
    }
    
    .sync-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 800px;
      margin: 0 auto;
      padding: 10px;
    }
    
    .keyboard-sync-section {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .btn-keyboard {
      padding: 8px 15px;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      border: none;
      color: white;
      font-weight: bold;
      background-color: #000000;
    }
    
    .btn-keyboard.active {
      background-color: #f8f8f8;
      box-shadow: 0 0 10px rgba(67, 56, 202, 0.5);
    }
    
    .quick-actions {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .btn-quick {
      padding: 5px 10px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      border: none;
      color: white;
      font-weight: bold;
    }
    
    .btn-host {
      background-color: var(--host-color);
    }
    
    .btn-player {
      background-color: var(--player-color);
    }
    
    .btn-all {
      background-color: var(--selected-color);
    }
    
    .btn-desync {
      background-color: #888;
    }
    
    .views-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .team-row {
      display: flex;
      align-items: center;
      gap: 5px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      padding: 5px;
      margin-bottom: 2px;
    }
    
    .team-views {
      display: grid;
      grid-template-columns: repeat(var(--views-per-row, 4), 1fr);
      gap: 5px;
      flex: 1;
    }
    
    .team-action {
      padding: 5px 10px;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      min-width: 60px;
      font-size: 12px;
    }
    
    .team-action.desync {
      background-color: #888;
    }
    
    .team-label {
      min-width: 50px;
      font-weight: bold;
      color: var(--light);
      padding: 0 5px;
      text-align: center;
      font-size: 12px;
    }
    
    .view-tile {
      aspect-ratio: 1;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s ease;
      border: 1px solid transparent;
      position: relative;
      width: 30px;
      height: 30px;
      margin: 0 auto;
      font-size: 12px;
    }
    
    .view-tile.host {
      background-color: rgba(249, 115, 22, 0.2);
      border-color: var(--host-color);
    }
    
    .view-tile.player {
      background-color: rgba(59, 130, 246, 0.2);
      border-color: var(--player-color);
    }
    
    .view-tile.selected {
      border-color: var(--selected-color);
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
    }
    
    .view-synced {
      position: absolute;
      right: -3px;
      top: -3px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--selected-color);
      display: none;
    }
    
    .view-tile.synced .view-synced {
      display: block;
    }
    
    .action-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }
    
    .btn {
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .btn:hover {
      background-color: var(--secondary);
    }
    
    .btn-secondary {
      background-color: #333;
    }
    
    .btn-secondary:hover {
      background-color: #555;
    }
    
    .sync-status {
      text-align: center;
      margin-top: 20px;
      font-size: 14px;
      color: #888;
    }
    
    .keyboard-preview {
      padding: 10px;
      border: 1px solid #555;
      border-radius: 4px;
      background-color: #333;
      color: var(--light);
      font-size: 14px;
      flex: 1;
      min-height: 20px;
      max-width: 400px;
    }
    
    .key-pressed {
      display: inline-block;
      padding: 3px 8px;
      margin: 2px;
      border-radius: 4px;
      background-color: #4f46e5;
      color: white;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="sync-container">
    <h1>Panel de sincronización</h1>
    
    <div class="keyboard-sync-section">
      <button id="sync-keyboard" class="btn-keyboard">Sincronizar el clave</button>
      <div id="keyboard-preview" class="keyboard-preview">Presionar teclas...</div>
    </div>
    
    <div class="quick-actions">
      <button id="sync-hosts" class="btn-quick btn-host">Host</button>
      <button id="sync-players" class="btn-quick btn-player">Player</button>
      <button id="sync-all" class="btn-quick btn-all">Seleccionar Todos</button>
      <button id="desync-all" class="btn-quick btn-desync">Quitar Todos</button>
    </div>
    
    <div id="views-container" class="views-container">
      <!-- Les équipes seront générées ici -->
    </div>
    
    <div class="sync-status" id="sync-status">
      Haga clic en una vista para sincronizarla o desincronizarla
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let viewsData = { views: [], viewsPerRow: 4 }; // Valeur par défaut de 4
      
      // Función para agrupar vistas por equipo (basado en filas)
      function groupViewsByTeam(views) {
        const teams = {};
        const viewsPerRow = viewsData.viewsPerRow; // Utilice valor dinámico
        
        console.log("Vues à grouper:", views.map(v => ({index: v.index, viewIndex: v.viewIndex, number: v.number})));
        
        // Utilice el orden de vista original tal como se define en viewsData
        views.forEach((view) => {
          // Utilice el índice si viewIndex no existe, o el número 1 como último recurso
          const viewPosition = typeof view.viewIndex !== 'undefined' ? view.viewIndex : 
                              (typeof view.index !== 'undefined' ? view.index : view.number - 1);
          
          // Determinar el número de línea (0, 1, 2, etc.)
          const rowNumber = Math.floor(viewPosition / viewsPerRow);
          const teamId = `row_${rowNumber}`;
          
          if (!teams[teamId]) {
            teams[teamId] = [];
          }
          
          teams[teamId].push(view);
          console.log(`Vue ${view.number} (index ${viewPosition}) -> Ligne ${rowNumber + 1}`);
        });
        
        // Ordenar las vistas en cada equipo para una visualización consistente
        Object.keys(teams).forEach(teamId => {
          // Intente ordenar por viewIndex si está disponible, de lo contrario por índice, de lo contrario por número
          teams[teamId].sort((a, b) => {
            if (typeof a.viewIndex !== 'undefined' && typeof b.viewIndex !== 'undefined') {
              return a.viewIndex - b.viewIndex;
            } else if (typeof a.index !== 'undefined' && typeof b.index !== 'undefined') {
              return a.index - b.index;
            } else {
              return a.number - b.number;
            }
          });
          
          const rowNumber = parseInt(teamId.split('_')[1]) || 0;
          console.log(`Ligne ${rowNumber + 1} contient ${teams[teamId].length} vues: ${teams[teamId].map(v => v.number).join(', ')}`);
        });
        
        return teams;
      }
      
      // Función para agrupar vistas por equipo
      function renderTeamViews(viewsData) {
        const container = document.getElementById('views-container');
        container.innerHTML = '';
        
        const teams = groupViewsByTeam(viewsData.views);
        
        // Ordenar equipos por número de línea
        const sortedTeamIds = Object.keys(teams).sort((a, b) => {
          const rowA = parseInt(a.split('_')[1]) || 0;
          const rowB = parseInt(b.split('_')[1]) || 0;
          return rowA - rowB;
        });
        
        sortedTeamIds.forEach(teamId => {
          const teamViews = teams[teamId];
          const rowNumber = parseInt(teamId.split('_')[1]) || 0;
          
          const teamRow = document.createElement('div');
          teamRow.className = 'team-row';
          
          // Agregar una etiqueta de equipo (número de fila + 1 para comenzar en la fila 1)
          const teamLabel = document.createElement('div');
          teamLabel.className = 'team-label';
          teamLabel.textContent = `Team ${rowNumber + 1}`;
          teamRow.appendChild(teamLabel);
          
          const teamViewsGrid = document.createElement('div');
          teamViewsGrid.className = 'team-views';
          
          // Comprueba si todos los miembros del equipo están sincronizados
          const allSynced = teamViews.every(view => view.isSynchronized);
          
          // Mostrar vistas en orden de su índice
          teamViews.forEach(view => {
            const tile = createViewTile(view);
            teamViewsGrid.appendChild(tile);
          });
          
          const syncTeamButton = document.createElement('button');
          syncTeamButton.className = `team-action ${allSynced ? 'desync' : ''}`;
          syncTeamButton.textContent = allSynced ? 'Desync Ligne' : 'Sync Ligne';
          syncTeamButton.dataset.teamId = teamId;
          syncTeamButton.addEventListener('click', () => {
            toggleTeamSync(teamId, !allSynced);
          });
          
          teamRow.appendChild(teamViewsGrid);
          teamRow.appendChild(syncTeamButton);
          
          container.appendChild(teamRow);
        });
      }
      
      // Función para crear un mosaico de vista
      function createViewTile(view) {
        const tile = document.createElement('div');
        tile.className = `view-tile ${view.type}`;
        if (view.isSynchronized) {
          tile.classList.add('synced');
        }
        
        tile.dataset.index = view.index;
        
        // Texto directamente en el mosaico sin elementos secundarios adicionales
        tile.textContent = `${view.type === 'host' ? 'H' : 'P'}${view.number}`;
        
        const syncedIndicator = document.createElement('div');
        syncedIndicator.className = 'view-synced';
        
        tile.appendChild(syncedIndicator);
        
        tile.addEventListener('click', () => {
          toggleViewSync(view.index);
        });
        
        return tile;
      }
      
      // Función para sincronizar/desincronizar una vista inmediatamente
      function toggleViewSync(index) {
        // Récupérer l'état actuel de la vue
        const view = viewsData.views.find(v => v.index === index);
        if (!view) return;
        
        // Si la vista ya está sincronizada la desincronizamos
        // Si no, lo sincronizamos.
        if (view.isSynchronized) {
          // Desincronizar esta vista (sincronizar todas las demás vistas sincronizadas)
          const otherIndices = viewsData.views
            .filter(v => v.index !== index && v.isSynchronized)
            .map(v => v.index);
          
          if (window.syncAPI) {
            window.syncAPI.synchronizeViews(otherIndices);
          }
        } else {
          // Sincronizar esta vista con vistas ya sincronizadas
          const indicesToSync = [...viewsData.views
            .filter(v => v.isSynchronized)
            .map(v => v.index), index];
          
          if (window.syncAPI) {
            window.syncAPI.synchronizeViews(indicesToSync);
          }
        }
        
        // Estado de actualización
        updateSyncStatus();
      }
      
      // Función para sincronizar/desincronizar un equipo completo
      function toggleTeamSync(teamId, shouldSync) {
        const teams = groupViewsByTeam(viewsData.views);
        const teamViews = teams[teamId] || [];
        
        if (teamViews.length === 0) return;
        
        const teamIndices = teamViews.map(view => view.index);
        
        if (shouldSync) {
          // Sincronice este equipo mientras mantiene sincronizadas otras vistas
          const currentlySyncedIndices = viewsData.views
            .filter(view => view.isSynchronized && !teamIndices.includes(view.index))
            .map(view => view.index);
          
          // Fusionar pistas sincronizadas actualmente con pistas del equipo
          const allIndicesToSync = [...currentlySyncedIndices, ...teamIndices];
          
          if (window.syncAPI) {
            window.syncAPI.synchronizeViews(allIndicesToSync);
          }
        } else {
          // Dessincronizar solo este equipo
          // Mantenemos todas las demás vistas sincronizadas tal como están
          const otherSyncedIndices = viewsData.views
            .filter(view => !teamIndices.includes(view.index) && view.isSynchronized)
            .map(view => view.index);
          
          if (window.syncAPI) {
            window.syncAPI.synchronizeViews(otherSyncedIndices);
          }
        }
      }
      
      // Actualizar el estado de sincronización
      function updateSyncStatus() {
        const syncedCount = viewsData.views.filter(view => view.isSynchronized).length;
        const statusEl = document.getElementById('sync-status');
        
        if (syncedCount === 0) {
          statusEl.textContent = 'Aucune vue synchronisée';
        } else {
          statusEl.textContent = `${syncedCount} vue(s) synchronisée(s)`;
        }
      }
      
      // Variables para el modo de teclado sincronizado
      let keyboardSyncActive = false;
      let activeKeys = new Set();
      
      // Función para sincronizar un tipo específico (host, reproductor, todos)
      function syncByType(type) {
        let indicesToSync = [];
        
        if (type === 'host') {
          indicesToSync = viewsData.views
            .filter(view => view.type === 'host')
            .map(view => view.index);
        } else if (type === 'player') {
          indicesToSync = viewsData.views
            .filter(view => view.type === 'player')
            .map(view => view.index);
        } else if (type === 'all') {
          indicesToSync = viewsData.views
            .map(view => view.index);
        } else if (type === 'none') {
          indicesToSync = []; // Desincronizar todo
        }
        
        if (window.syncAPI && type !== 'none') {
          window.syncAPI.synchronizeViews(indicesToSync);
        } else if (window.syncAPI && type === 'none') {
          window.syncAPI.synchronizeViews([]);
        }
      }
      
      // Controlador de eventos del teclado para capturar pulsaciones de teclas
      function handleKeyDown(event) {
        if (!keyboardSyncActive) return;
        
        // Ignorar eventos repetidos para evitar duplicados
        if (event.repeat) return;
        
        // Obtener el nombre de la clave
        const key = event.key;
        
        // Añadir al conjunto de claves activas
        activeKeys.add(key);
        
        // Actualizar la vista previa de la clave
        updateKeyboardPreview();
        
        // Enviar evento a vistas sincronizadas a través de API
        if (window.syncAPI) {
          // Envíe todas las claves de la misma manera, sin procesamiento especial
          window.syncAPI.sendKeyboardEvent({
            type: 'keydown',
            key: key
          });
        }
        
        // Evitar el comportamiento predeterminado excepto Escape
        if (!event.target.matches('input, textarea') && key !== 'Escape') {
          event.preventDefault();
        }
      }
      
      function handleKeyUp(event) {
        if (!keyboardSyncActive) return;
        
        // Obtener el nombre de la clave
        const key = event.key;
        
        console.log('Keyup reçu pour:', key);
        
        // Eliminar del conjunto de claves activas
        activeKeys.delete(key);
        
        // Si se suelta la tecla Shift, verifique si hay alguna tecla de movimiento activa
        // y también liberarlos para evitar que se queden atascados
        if (key === 'Shift') {
          // Estas teclas se utilizan a menudo con Shift para ejecutar
          const movementKeys = ['z', 'q', 's', 'd', 'Z', 'Q', 'S', 'D', 'w', 'a', 'W', 'A'];
          
          movementKeys.forEach(moveKey => {
            if (activeKeys.has(moveKey)) {
              console.log('Relâchement forcé de la touche de mouvement:', moveKey);
              activeKeys.delete(moveKey);
              
              // Enviar un evento keyup para esta tecla
              if (window.syncAPI) {
                window.syncAPI.sendKeyboardEvent({
                  type: 'keyup',
                  key: moveKey
                });
              }
            }
          });
        }
        
        // Actualizar la vista previa de la clave
        updateKeyboardPreview();
        
        // Enviar evento a vistas sincronizadas a través de API
        if (window.syncAPI) {
          // Envíe todas las claves de la misma manera, sin procesamiento especial
          window.syncAPI.sendKeyboardEvent({
            type: 'keyup',
            key: key
          });
        }
        
        // Evitar el comportamiento predeterminado excepto Escape
        if (!event.target.matches('input, textarea') && key !== 'Escape') {
          event.preventDefault();
        }
      }
      
      // Actualizar la vista previa visual de las claves activas
      function updateKeyboardPreview() {
        const previewEl = document.getElementById('keyboard-preview');
        
        if (activeKeys.size === 0) {
          previewEl.textContent = 'Appuyez sur des touches...';
        } else {
          previewEl.innerHTML = '';
          
          // Crea un elemento para cada clave activa
          activeKeys.forEach(key => {
            const keyElement = document.createElement('span');
            keyElement.className = 'key-pressed';
            keyElement.textContent = key === ' ' ? 'Espace' : key;
            previewEl.appendChild(keyElement);
          });
        }
      }
      
      // Función para alternar el modo de sincronización del teclado
      function toggleKeyboardSync() {
        keyboardSyncActive = !keyboardSyncActive;
        
        const keyboardButton = document.getElementById('sync-keyboard');
        const previewEl = document.getElementById('keyboard-preview');
        
        if (keyboardSyncActive) {
          // Habilitar la sincronización del teclado
          keyboardButton.classList.add('active');
          keyboardButton.textContent = 'Clavier Actif';
          previewEl.textContent = 'Appuyez sur des touches...';
          
          // Agregar oyentes de eventos al documento
          document.addEventListener('keydown', handleKeyDown);
          document.addEventListener('keyup', handleKeyUp);
        } else {
          // Deshabilitar la sincronización del teclado
          keyboardButton.classList.remove('active');
          keyboardButton.textContent = 'Sync Clavier';
          previewEl.textContent = 'Appuyez sur des touches...';
          
          // Eliminar oyentes de eventos
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
          
          // Liberar todas las teclas activas
          if (activeKeys.size > 0) {
            if (window.syncAPI) {
              activeKeys.forEach(key => {
                window.syncAPI.sendKeyboardEvent({
                  type: 'keyup',
                  key: key
                });
              });
            }
            activeKeys.clear();
          }
        }
      }
      
      // Controladores para botones de sincronización rápida
      document.getElementById('sync-hosts').addEventListener('click', () => {
        syncByType('host');
      });
      
      document.getElementById('sync-players').addEventListener('click', () => {
        syncByType('player');
      });
      
      document.getElementById('sync-all').addEventListener('click', () => {
        syncByType('all');
      });
      
      document.getElementById('desync-all').addEventListener('click', () => {
        syncByType('none');
      });
      
      // Controlador para el botón de sincronización del teclado
      document.getElementById('sync-keyboard').addEventListener('click', toggleKeyboardSync);
      
      // Escuche las actualizaciones del estado de visualización
      if (window.syncAPI) {
        window.syncAPI.onViewsUpdate(data => {
          viewsData = data;
          // Actualizar la variable CSS para el número de vistas por fila
          document.documentElement.style.setProperty('--views-per-row', data.viewsPerRow || 4);
          renderTeamViews(viewsData);
          updateSyncStatus();
        });
        
        // Solicitar el estado inicial de las vistas
        window.syncAPI.requestViewsState();
      }
    });
  </script>
</body>
</html> 